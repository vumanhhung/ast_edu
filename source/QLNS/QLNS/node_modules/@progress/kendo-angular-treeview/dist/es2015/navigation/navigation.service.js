import { Injectable } from '@angular/core';
import { NavigationModel } from './navigation-model';
import { nodeIndex } from '../utils';
import { Keys } from './keys';
import { Subject } from "rxjs/Subject";
const sibling = (item, direction) => item[direction] || item;
/**
 * @hidden
 */
export class NavigationService {
    constructor() {
        this.expands = new Subject();
        this.moves = new Subject();
        this.checks = new Subject();
        this.selects = new Subject();
        this.navigable = true;
        this.actions = {
            [Keys.up]: () => this.activate(sibling(this.focusableItem, 'prev')),
            [Keys.down]: () => this.activate(sibling(this.focusableItem, 'next')),
            [Keys.left]: () => (this.expand({ expand: false, intercept: this.moveToParent.bind(this) })),
            [Keys.right]: () => (this.expand({ expand: true, intercept: this.moveToChild.bind(this) })),
            [Keys.home]: () => this.activate(this.model.firstNode()),
            [Keys.end]: () => this.activate(this.model.lastNode()),
            [Keys.enter]: () => this.navigable && this.selectIndex(nodeIndex(this.activeItem)),
            [Keys.space]: () => this.navigable && this.checkIndex(nodeIndex(this.activeItem))
        };
        this.isFocused = false;
        this._model = new NavigationModel();
    }
    get model() {
        return this._model;
    }
    set model(model) {
        this._model = model;
    }
    get activeIndex() {
        return nodeIndex(this.activeItem) || null;
    }
    get focusableItem() {
        return this.activeItem || this.model.firstNode();
    }
    get isActiveExpanded() {
        return this.activeItem && this.activeItem.children.length > 0;
    }
    activate(item) {
        if (!this.navigable || !item || this.isActive(nodeIndex(item))) {
            return;
        }
        this.isFocused = true;
        this.activeItem = item || this.activeItem;
        this.notifyMove();
    }
    activateParent(index) {
        this.activate(this.model.findParent(index));
    }
    activateIndex(index) {
        if (!index) {
            return;
        }
        this.activate(this.model.findNode(index));
    }
    activateClosest(index) {
        if (!index || nodeIndex(this.focusableItem) !== index) {
            return;
        }
        this.activeItem = this.model.closestNode(index);
        this.notifyMove();
    }
    activateFocusable() {
        if (this.activeItem) {
            return;
        }
        this.activeItem = this.model.firstNode();
        this.notifyMove();
    }
    deactivate() {
        if (!this.navigable || !this.isFocused) {
            return;
        }
        this.isFocused = false;
        this.notifyMove();
    }
    checkIndex(index) {
        if (!this.isDisabled(index)) {
            this.checks.next(index);
        }
    }
    selectIndex(index) {
        if (!this.isDisabled(index)) {
            this.selects.next(index);
        }
    }
    isActive(index) {
        if (!index) {
            return false;
        }
        return this.isFocused && this.activeIndex === index;
    }
    isFocusable(index) {
        return nodeIndex(this.focusableItem) === index;
    }
    isDisabled(index) {
        return this.model.findNode(index).disabled;
    }
    registerItem(index, disabled) {
        this.model.registerItem(index, disabled);
    }
    unregisterItem(index) {
        if (this.isActive(index)) {
            this.activateParent(index);
        }
        this.model.unregisterItem(index);
    }
    move(e) {
        if (!this.navigable) {
            return;
        }
        const moveAction = this.actions[e.keyCode];
        if (!moveAction) {
            return;
        }
        moveAction();
        e.preventDefault();
    }
    expand({ expand, intercept }) {
        const index = nodeIndex(this.activeItem);
        if (!index || intercept(index)) {
            return;
        }
        this.notifyExpand(expand);
    }
    moveToParent() {
        if (this.isActiveExpanded) {
            return false;
        }
        this.activate(this.model.findParent(nodeIndex(this.activeItem)));
        return true;
    }
    moveToChild() {
        if (!this.isActiveExpanded) {
            return false;
        }
        this.activate(this.model.findChild(nodeIndex(this.activeItem)));
        return true;
    }
    notifyExpand(expand) {
        this.expands.next(this.navigationState(expand));
    }
    notifyMove() {
        this.moves.next(this.navigationState());
    }
    navigationState(expand = false) {
        return ({ expand, index: nodeIndex(this.activeItem), isFocused: this.isFocused });
    }
}
NavigationService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NavigationService.ctorParameters = () => [];
