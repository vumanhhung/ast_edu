import { IndexBuilderService } from '../index-builder.service';
const last = (list) => list[list.length - 1];
const safe = node => (node || {});
const safeChildren = node => (safe(node).children || []);
const findLast = node => {
    let lastNode = node;
    let children = [].concat(safeChildren(node));
    while (children.length) {
        children = children.concat(safeChildren(last(children)));
        lastNode = children.shift();
    }
    return lastNode;
};
const link = (node) => {
    const { prev, next } = node;
    if (prev) {
        prev.next = node;
    }
    if (next) {
        next.prev = node;
    }
};
const unlink = (prev, next) => {
    if (prev) {
        prev.next = next;
    }
    if (next) {
        next.prev = prev;
    }
};
/**
 * @hidden
 */
export class NavigationModel {
    constructor() {
        this.ib = new IndexBuilderService();
        this.nodes = [];
    }
    firstNode() {
        return this.nodes[0] || null;
    }
    lastNode() {
        const node = this.nodes[this.nodes.length - 1];
        if (!node) {
            return null;
        }
        return findLast(last(this.container(node))) || node;
    }
    closestNode(index) {
        const { prev } = safe(this.findNode(index));
        const sibling = prev || this.firstNode();
        return safe(sibling).index === index ? this.sibling(sibling, 1) : sibling;
    }
    findNode(index) {
        return this.find(index, this.nodes);
    }
    findParent(index) {
        const parentLevel = this.ib.level(index) - 1;
        return this.findNode(this.ib.indexForLevel(index, parentLevel));
    }
    findChild(index) {
        return safeChildren(this.findNode(index))[0] || null;
    }
    registerItem(index, disabled) {
        const children = [];
        const level = this.ib.level(index);
        const parent = this.findParent(index);
        if (parent || level === 1) {
            const prev = this.prevNode(parent, index);
            const next = this.nextNode(parent, index);
            const node = { children, index, parent, prev, next, disabled };
            link(node);
            this.insert(node, parent);
        }
    }
    unregisterItem(index) {
        const node = this.find(index, this.nodes);
        if (!node) {
            return;
        }
        unlink(node.prev, this.nextNode(node.parent, node.index));
        const children = this.container(node.parent);
        children.splice(children.indexOf(node), 1);
    }
    childLevel(nodes) {
        if (!nodes || !nodes.length) {
            return 1;
        }
        return this.ib.level(nodes[0].index);
    }
    container(node) {
        return node ? node.children : this.nodes;
    }
    find(index, nodes) {
        const childLevel = this.childLevel(nodes);
        const indexToMatch = this.ib.indexForLevel(index, childLevel);
        const isLeaf = childLevel === this.ib.level(index);
        const node = nodes.find(n => n.index === indexToMatch);
        if (!node) {
            return null;
        }
        return isLeaf ? node : this.find(index, node.children);
    }
    closestIndexPosition(nodes, index) {
        const indexPosition = this.ib.lastLevelIndex(index);
        let idx = 0;
        while (idx < nodes.length) {
            if (this.ib.lastLevelIndex(nodes[idx].index) > indexPosition) {
                return idx;
            }
            idx += 1;
        }
        return idx;
    }
    insert(node, parent) {
        const nodes = this.container(parent);
        nodes.splice(this.closestIndexPosition(nodes, node.index), 0, node);
    }
    prevNode(parent, index) {
        const nodes = this.container(parent);
        const partialList = nodes.slice(0, this.closestIndexPosition(nodes, index));
        return findLast(last(partialList)) || parent || null;
    }
    nextNode(parent, index) {
        const children = this.container(parent);
        const currentNode = this.findNode(index);
        if (!parent && currentNode) {
            return this.sibling(currentNode, 1);
        }
        const nodeIndex = this.closestIndexPosition(children, index);
        const child = children.slice(nodeIndex)[0];
        return child ? child : this.sibling(parent, 1);
    }
    sibling(node, offset) {
        if (!node) {
            return null;
        }
        const parent = this.findParent(node.index);
        const container = this.container(parent);
        return container[container.indexOf(node) + offset] || this.sibling(parent, offset) || null;
    }
}
