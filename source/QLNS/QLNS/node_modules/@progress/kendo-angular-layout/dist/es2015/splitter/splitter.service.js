import { isDevMode, EventEmitter, NgZone, Injectable } from '@angular/core';
const SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#toc-size';
/**
 * @hidden
 */
export class SplitterService {
    constructor(zone) {
        this.zone = zone;
        this.layoutChange = new EventEmitter();
        this.containerSize = () => { };
    }
    tryToggle(paneIndex) {
        const pane = this.pane(paneIndex);
        if (pane.collapsible) {
            pane.collapsed = !pane.collapsed;
            pane.collapsedChange.emit(pane.collapsed);
            this.emit(this.layoutChange, {});
        }
        return pane.collapsible;
    }
    dragState(splitbarIndex) {
        let index = splitbarIndex;
        let resizedPane = this.pane(splitbarIndex);
        let otherPane = this.pane(splitbarIndex + 1);
        // determine which pane to resize
        if (otherPane.collapsible || otherPane.fixedSize) {
            index = splitbarIndex + 1;
            resizedPane = this.pane(splitbarIndex + 1);
            otherPane = this.pane(splitbarIndex);
        }
        // calculate resizing constraints
        const max = resizedPane.computedSize + otherPane.computedSize;
        const px = s => this.toPixels(s);
        return {
            index,
            initial: resizedPane.computedSize,
            min: px(resizedPane.min) || max - px(otherPane.max) || 0,
            max: px(resizedPane.max) || max - px(otherPane.min) || max
        };
    }
    setSize(state, delta) {
        const clamp = (min, max, v) => Math.min(max, Math.max(min, v));
        const newSize = clamp(state.min, state.max, state.initial + delta);
        const pane = this.pane(state.index);
        const splitterSize = this.containerSize();
        let size = "";
        if (this.isPercent(pane.size)) {
            size = (100 * newSize / splitterSize) + "%";
        }
        else {
            size = newSize + "px";
        }
        pane.size = size;
        this.emit(pane.sizeChange, size);
        this.emit(this.layoutChange, {});
    }
    isDraggable(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev.resizable && next.resizable;
        const nearCollapsedPane = prev.collapsed || next.collapsed;
        return betweenResizablePanes && !nearCollapsedPane;
    }
    isStatic(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev.resizable && next.resizable;
        const nearCollapsiblePane = prev.collapsible || next.collapsible;
        return !betweenResizablePanes && !nearCollapsiblePane;
    }
    pane(index) {
        if (!this.panes) {
            throw new Error("Panes not initialized");
        }
        if (index < 0 || index >= this.panes.length) {
            throw new Error("Index out of range");
        }
        return this.panes[index];
    }
    configure({ panes, orientation, containerSize }) {
        this.panes = panes;
        this.panes.forEach((pane, index) => {
            pane.order = index * 2;
            pane.orientation = orientation;
        });
        if (isDevMode()) {
            const allFixed = panes.length && !panes.some(pane => !pane.fixedSize);
            if (allFixed) {
                throw new Error(`
                    The Splitter should have at least one pane without a set size.
                    See ${SIZING_DOC_LINK} for more information.
                `);
            }
        }
        this.containerSize = containerSize;
    }
    isPercent(size) {
        return /%$/.test(size);
    }
    toPixels(size) {
        let result = parseInt(size, 10);
        if (this.isPercent(size)) {
            result = (this.containerSize() * result / 100);
        }
        return result;
    }
    emit(emitter, args) {
        if (emitter.observers.length) {
            this.zone.run(() => emitter.emit(args));
        }
    }
}
SplitterService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
SplitterService.ctorParameters = () => [
    { type: NgZone, },
];
