"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#toc-size';
/**
 * @hidden
 */
var SplitterService = /** @class */ (function () {
    function SplitterService(zone) {
        this.zone = zone;
        this.layoutChange = new core_1.EventEmitter();
        this.containerSize = function () { };
    }
    SplitterService.prototype.tryToggle = function (paneIndex) {
        var pane = this.pane(paneIndex);
        if (pane.collapsible) {
            pane.collapsed = !pane.collapsed;
            pane.collapsedChange.emit(pane.collapsed);
            this.emit(this.layoutChange, {});
        }
        return pane.collapsible;
    };
    SplitterService.prototype.dragState = function (splitbarIndex) {
        var _this = this;
        var index = splitbarIndex;
        var resizedPane = this.pane(splitbarIndex);
        var otherPane = this.pane(splitbarIndex + 1);
        // determine which pane to resize
        if (otherPane.collapsible || otherPane.fixedSize) {
            index = splitbarIndex + 1;
            resizedPane = this.pane(splitbarIndex + 1);
            otherPane = this.pane(splitbarIndex);
        }
        // calculate resizing constraints
        var max = resizedPane.computedSize + otherPane.computedSize;
        var px = function (s) { return _this.toPixels(s); };
        return {
            index: index,
            initial: resizedPane.computedSize,
            min: px(resizedPane.min) || max - px(otherPane.max) || 0,
            max: px(resizedPane.max) || max - px(otherPane.min) || max
        };
    };
    SplitterService.prototype.setSize = function (state, delta) {
        var clamp = function (min, max, v) { return Math.min(max, Math.max(min, v)); };
        var newSize = clamp(state.min, state.max, state.initial + delta);
        var pane = this.pane(state.index);
        var splitterSize = this.containerSize();
        var size = "";
        if (this.isPercent(pane.size)) {
            size = (100 * newSize / splitterSize) + "%";
        }
        else {
            size = newSize + "px";
        }
        pane.size = size;
        this.emit(pane.sizeChange, size);
        this.emit(this.layoutChange, {});
    };
    SplitterService.prototype.isDraggable = function (splitBarIndex) {
        var prev = this.pane(splitBarIndex);
        var next = this.pane(splitBarIndex + 1);
        var betweenResizablePanes = prev.resizable && next.resizable;
        var nearCollapsedPane = prev.collapsed || next.collapsed;
        return betweenResizablePanes && !nearCollapsedPane;
    };
    SplitterService.prototype.isStatic = function (splitBarIndex) {
        var prev = this.pane(splitBarIndex);
        var next = this.pane(splitBarIndex + 1);
        var betweenResizablePanes = prev.resizable && next.resizable;
        var nearCollapsiblePane = prev.collapsible || next.collapsible;
        return !betweenResizablePanes && !nearCollapsiblePane;
    };
    SplitterService.prototype.pane = function (index) {
        if (!this.panes) {
            throw new Error("Panes not initialized");
        }
        if (index < 0 || index >= this.panes.length) {
            throw new Error("Index out of range");
        }
        return this.panes[index];
    };
    SplitterService.prototype.configure = function (_a) {
        var panes = _a.panes, orientation = _a.orientation, containerSize = _a.containerSize;
        this.panes = panes;
        this.panes.forEach(function (pane, index) {
            pane.order = index * 2;
            pane.orientation = orientation;
        });
        if (core_1.isDevMode()) {
            var allFixed = panes.length && !panes.some(function (pane) { return !pane.fixedSize; });
            if (allFixed) {
                throw new Error("\n                    The Splitter should have at least one pane without a set size.\n                    See " + SIZING_DOC_LINK + " for more information.\n                ");
            }
        }
        this.containerSize = containerSize;
    };
    SplitterService.prototype.isPercent = function (size) {
        return /%$/.test(size);
    };
    SplitterService.prototype.toPixels = function (size) {
        var result = parseInt(size, 10);
        if (this.isPercent(size)) {
            result = (this.containerSize() * result / 100);
        }
        return result;
    };
    SplitterService.prototype.emit = function (emitter, args) {
        if (emitter.observers.length) {
            this.zone.run(function () { return emitter.emit(args); });
        }
    };
    SplitterService.decorators = [
        { type: core_1.Injectable },
    ];
    /** @nocollapse */
    SplitterService.ctorParameters = function () { return [
        { type: core_1.NgZone, },
    ]; };
    return SplitterService;
}());
exports.SplitterService = SplitterService;
